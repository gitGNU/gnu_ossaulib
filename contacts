#!/usr/bin/env guile

Contacts - top level executable guile -*- scheme -*- script

!#

(turn-on-debugging)

(use-modules (ice-9 regex))

(eval-when (load compile)
  (let* ((bindir (dirname (car (command-line))))
	 (absdir (cond ((string=? bindir ".")
			(getcwd))
		       ((string-match "^/" bindir)
			bindir)
		       (else (in-vicinity (getcwd) bindir)))))
    (set! %load-path (cons absdir %load-path))))

(define (with-working-directory* dir thunk)
  (let ((outer (getcwd)))
    (dynamic-wind
	(lambda () (chdir dir))
	thunk
	(lambda () (chdir outer)))))

(define-macro (with-working-directory dir . body)
  `(with-working-directory* ,dir (lambda () ,@body)))

(use-modules (ossau bbdb-from)
	     (ossau bbdb-to))

(define (main . args)
  (if (null? args)
      (usage-error "You need to give a command argument, such as `from'."))
  (let* ((command (car args))
	 (command-proc (and=> (assoc command command-table) cadr)))
    (if command-proc
	(command-proc (cdr args))
	(usage-error "`~a' is not a recognized command." command))))

(define (usage-error msg . args)
  (let (;;(possible-commands
	;; (substring (apply string-append
	;;		   (map (lambda (command-entry)
	;;			  (string-append " | " (car command-entry)))
	;;			command-table))
	;;	    3))
	(details (apply string-append
			(map (lambda (command-entry)
			       (string-append "\t"
					      (car (command-line))
					      " "
					      (car command-entry)
					      " "
					      (caddr command-entry)
					      "\n"))
			     command-table))))
    (newline)
    (error (apply format #f
		  (string-append msg
				 "\n\n"
				 ;;"Usage: " (car (command-line))
				 ;;" (" possible-commands ") ...\n"
				 "Possible invocations are:\n"
				 details)
		  args))))

(define (do-from args)
  ;; We need 2 arguments, a branch name and a file (or directory) name
  ;; to import from.
  (or (= (length args) 2)
      (usage-error "The `from' command needs 2 arguments:
- a branch name
- and a file (or directory) name to import from. ~s" args))
  (let ((branch (car args))
	(source (cadr args)))
    ;; Initialize the Git repository if it doesn't already exist.
    (ensure-repository)
    (with-working-directory repository-dir
      ;; Import and `git add' master format contact files.
      (import-and-stage-contacts branch source)
      ;; Commit them as an import.
      (system "git commit -m ~s" (format #f "Import ~a" args))
      ;; Switch to master and cherry-pick the changes.
      (system "git checkout master")
      (system "git cherry-pick ~a" branch))))

(define (import-and-stage-contacts branch source)
  ;; Try to switch to the named branch.
  (or (zero? (system "git checkout ~a >/dev/null 2>&1" branch))
      ;; Branch does not already exist, so must be created.
      (begin
	(system "git checkout ~a" root-tag-name)
	(system "git checkout -b ~a" branch)))
  ;; Delete all existing contacts.
  (system "rm -f _*")
  ;; Export from the source (assuming for the moment that it is a
  ;; BBDB source).
  (bbdb-from source)
  ;; Stage the generated contacts.
  (system "git add _*"))

(define (do-to args)
  ;; We need 2 arguments, a branch name and a file (or directory) name
  ;; to export to.
  (or (= (length args) 2)
      (usage-error "The `to' command needs 2 arguments:
- a branch name
- and a file (or directory) name to export to. ~s" args))
  (let ((branch (car args))
	(target (cadr args)))
    ;; Initialize the Git repository if it doesn't already exist.
    (ensure-repository)
    (with-working-directory repository-dir
      ;; Switch to the master branch.
      (system "git checkout master")
      ;; Export to the target (assuming for the moment that it is a
      ;; BBDB target).
      (with-output-to-file target
	(lambda ()
	  (bbdb-to (getcwd))))
      ;; Now reimport from the target.  The point of this is that the
      ;; target format probably doesn't preserve every field that we
      ;; have in the master format, and we don't want a future import
      ;; of this target to look like a _deletion_ of those
      ;; non-preserved fields.
      (import-and-stage-contacts branch target)
      ;; Commit them as an export and reimport.
      (system "git commit -m ~s" "Export and reimport")
      ;; Switch back to master.
      (system "git checkout master"))))

(define command-table `(("from" ,do-from "<branch> <file-or-dir>")
			("to" ,do-to "<branch> <file-or-dir>")))

(define contacts-dir (in-vicinity (getenv "HOME") ".contacts"))
(define repository-dir (in-vicinity contacts-dir "repository"))
(define repository-stamp-file-name "CONTACTS")
(define root-tag-name "___root___")

(let ((primitive-system system))
  (set! system (lambda (cmd . args)
		 (primitive-system (apply format #f cmd args)))))

(define (ensure-repository)
  (ensure-directory contacts-dir)
  (ensure-directory repository-dir)
  (with-working-directory repository-dir
    (or (file-exists? ".git")
	(begin
	  (system "git init")
	  (with-output-to-file repository-stamp-file-name
	    (lambda ()
	      (format #t "Created on ~a\n"
		      (strftime "%Y%m%d-%H%M" (localtime (current-time))))))
	  (system "git add ~s" repository-stamp-file-name)
	  (system "git commit -m ~s" "Repository created")
	  (system "git tag ~a" root-tag-name)))))

(define (ensure-directory dir)
  (if (file-exists? dir)
      (or (file-is-directory? dir)
	  (error "`~a' already exists but is not a directory." dir))
      (mkdir dir)))

;; Invoke `main'.
(apply main (cdr (command-line)))
